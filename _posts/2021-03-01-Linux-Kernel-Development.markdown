---
layout: post
title: Linux Kernel Development
---

[TOC]

## 进程管理

1. 什么是进程

2. 内核如何描述进程

3. 进程的生命周期

4. 进程之间的关系

5. 如何创建进程

6. 内核中的线程如何实现

7. 如何终结进程

## 进程调度

1. 解决什么问题
   保证系统的响应时间, 提高CPU的利用率

2. 不同类型的进程
   - IO密集
   - CPU密集

3. 不同的调度算法

## 系统调用

1. 为什么需要系统调用?
   - 提供给上层的应用程序抽象的接口, 避免直接面对硬件的复杂性
   - 把应用程序和内核分离开, 保证系统的安全卡靠

2. 系统调用的工作过程
   1) 用户请求系统调用
      - 系统调用号  --> 体系架构相关的寄存器
      - 系统调用参数 --> 体系架构相关的寄存器
   2) 产生软中断
   3) 进入系统调用中断处理程序
   4) 根据系统调用号转到对应的处理程序
   5) 取出寄存器中的参数, 执行系统调用

---

## 内核同步
1. 什么是临界区, 竞争条件?

2. 自旋锁, 信号量, 互斥体这三种类型的锁的原理和区别


---

## 国防科技大学操作系统课程

### 进程和进程调度
    进程是程序在运行时CPU的状态, 内存的状态, 占用的相关资源的集合, 是
    程序运行的活动. 进程在执行过程中总是在, "New" "Ready" "Running"
    "Block" "Exit"这些状态之间进行转换的. 操作系统的调度实际上是在合适
    的时机, 按照某种原则选择处于就绪状态的进程占用CPU, 选取进程的原则
    实际上体现了调度算法, 当有新就绪的进程或者有新的阻塞状态的进程, 说
    明出现了满足调度发生的条件, 实际的调度动作是在内核返回用户程序之前
    进行的.

### 内存管理
1. 如何"放"的问题:
   - 单道程序连续分配
     每次只把一个完整程序文件读入到内存, 并连续存放
     
   - 多道程序连续分配
     首先把内存划分成空闲块队列, 然后按照进程的调度顺序, 以此从空闲块
     队列中为进程分配内存空间, 每次分配可以采取不同的分配策略(首次满足
     /最优满足/最大满足), 程序文件同样是连续的分配到空闲块中的. 注意,
     每次分配之后需要更空闲块队列, 空闲块队列可以用BitMap数组描述, 因
     为每个空闲块的大小相同, 可以用0/1表示块的使用状态, 当程序的内存空
     间被回收时, 需要更新BitMap的状态.
     
   - 页式内存分配
     将程序的逻辑地址空间和实际的物理地址空间分开, 两种地址空间被划分
     成大小相等的页(Page)/页桢(Frame), 这里的逻辑地址空间大小只受寻址
     范围的限制, 程序可以认为有一个独占的地址空间. 操作系统为每个进程
     维护一个页表, 用来映射逻辑页号和物理页号, 然后根据页号以及页内偏
     移计算实际的物理地址, 页的大小通常设置成2的幂次, 方便硬件进行地址
     转换操作, 通过页式内存分配的方式可以方便实现内存的共享和保护机制,
     当需要共享时只需要让两个逻辑页对应相同的物理页即可, 在访问内存时
     通过检查页号范围, 可以避免内存访问非法的物理内存区域, 起到保护的
     作用. CPU提供了"快表", MMU相关的寄存器, 可以缓存进程的一部分页表
     项目, 这样就不必每次查OS维护的页表, 提高了访问内存的速度. 由于进
     程在运行过程中可能有些页暂时不在内存中, 而是在磁盘的交换分区中,
     因此页表项要提供必要的字段去维护进程中的页的状态, 告知操作系统在
     产生缺页错误时该从哪里得到页面的内容, 当物理内存不足时, 需要OS执
     行某中页淘汰策略, 这时页表项需要记录被淘汰的页在交换分区的位置.
     
   - 段式内存分配

   - 段页式内存分配 

   - 改进的页式内存分配

   - 多级页表内存分配